<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Météo Market 🪙</title>
  <style>
    :root{--bg:#0f172a;--card:#111827;--text:#e5e7eb;--muted:#94a3b8;--up:#22c55e;--down:#ef4444;--accent:#38bdf8}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:#0f172a;color:var(--text)}
    header{max-width:1100px;margin:20px auto;padding:0 16px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    h1{margin:0;font-size:24px} .badge{color:var(--muted);font-size:13px}
    table{border-collapse:collapse;width:100%;max-width:1100px;margin:10px auto;background:var(--card);border:1px solid #1f2937;border-radius:12px;overflow:hidden}
    th,td{padding:10px 12px;text-align:left;vertical-align:middle}
    th{cursor:pointer;color:var(--accent);user-select:none;background:#0b1223;position:sticky;top:0}
    tr:nth-child(even){background:#0f1626}
    .up{color:var(--up)} .down{color:var(--down)}
    .flag{font-size:18px;margin-right:6px}
    footer{max-width:1100px;margin:24px auto;padding:0 16px;color:var(--muted);font-size:13px}
    .right{text-align:right}
    .loading{max-width:1100px;margin:20px auto;padding:12px 16px;color:var(--muted)}
    .pill{display:inline-block;border:1px solid #243042;border-radius:999px;padding:4px 8px;font-size:12px;color:var(--muted);margin-left:8px}

    /* Sparkline */
    .spark svg{width:140px;height:36px;display:block}
    .spark .axis{stroke:#1f2937;stroke-width:1}
    .spark .line{fill:none;stroke-width:2}
    .spark .up{stroke:var(--up)} .spark .down{stroke:var(--down)}

    /* Tooltip + zone d'interaction */
    #tip{
      position:fixed; z-index:9999; display:none;
      background:#0b1223; color:#e5e7eb;
      border:1px solid #1f2937; border-radius:8px;
      padding:6px 8px; font-size:12px; pointer-events:none;
      box-shadow:0 6px 24px rgba(0,0,0,.35);
      white-space:nowrap;
    }
    .spark .marker{ fill:#e5e7eb; stroke:#0b1223; stroke-width:1.2; display:none }
    .spark .hit{ fill:transparent; pointer-events:all }
  </style>
</head>
<body>
  <header>
    <h1>🪙 Météo Market <span class="pill">gratuit · GitHub Pages</span></h1>
    <div class="badge" id="status">Chargement…</div>
  </header>

  <table id="tbl" hidden>
    <thead>
      <tr>
        <th onclick="setSort('name')">Coin (Pays)</th>
        <th onclick="setSort('price')" class="right">Cours (°C)</th>
        <th>Sparkline 24h</th>
        <th onclick="setSort('change')" class="right">Variation 24h</th>
        <th onclick="setSort('cap')" class="right">Cap météo</th>
      </tr>
    </thead>
    <tbody id="body"></tbody>
  </table>

  <div class="loading" id="loading">Fetching les ticks météo…</div>
  <div id="tip"></div>

  <footer>
    Source : <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo</a> (pas de clé, gratuit).  
    “Cours” = température actuelle. “Variation 24h” = différence vs hier, même heure.  
    “Cap météo” = temp × (1 + vent/100). Sparkline = 24 dernières heures.
  </footer>

<script>
/** --- Configuration des “coins” (capitale par pays) --- */
const COINS = [
  { country:"France",       city:"Paris",      flag:"🇫🇷", lat:48.8566, lon:  2.3522 },
  { country:"Royaume-Uni",  city:"Londres",    flag:"🇬🇧", lat:51.5074, lon: -0.1278 },
  { country:"Allemagne",    city:"Berlin",     flag:"🇩🇪", lat:52.5200, lon: 13.4050 },
  { country:"Espagne",      city:"Madrid",     flag:"🇪🇸", lat:40.4168, lon: -3.7038 },
  { country:"Italie",       city:"Rome",       flag:"🇮🇹", lat:41.9028, lon: 12.4964 },
  { country:"États-Unis",   city:"New York",   flag:"🇺🇸", lat:40.7128, lon:-74.0060 },
  { country:"Japon",        city:"Tokyo",      flag:"🇯🇵", lat:35.6762, lon:139.6503 },
  { country:"Australie",    city:"Sydney",     flag:"🇦🇺", lat:-33.8688,lon:151.2093 },
  { country:"Égypte",       city:"Le Caire",   flag:"🇪🇬", lat:30.0444, lon: 31.2357 },
  { country:"Brésil",       city:"São Paulo",  flag:"🇧🇷", lat:-23.5505,lon:-46.6333 },
  { country:"Mexique",      city:"Mexico",     flag:"🇲🇽", lat:19.4326, lon:-99.1332 },
  { country:"Inde",         city:"Delhi",      flag:"🇮🇳", lat:28.6139, lon: 77.2090 },
];

/** --- State + rendering --- */
let ticks = [];           // {name, price, change, cap, temps24:number[], times24:string[]}
let sortBy = 'cap';

function setSort(k){ sortBy=k; render(); }

/** Sparkline avec data-attrs + zone d'interaction */
function sparkSVG(arr, times, change){
  if(!arr || arr.length < 2) return '';
  const w=140, h=36, pad=3;
  const min = Math.min(...arr);
  const max = Math.max(...arr);
  const span = (max-min) || 1;
  const N = arr.length;
  const X = i => pad + (i*(w-2*pad))/(N-1);
  const Y = v => h - (pad + ((v-min)* (h-2*pad)/span));

  let d = `M ${X(0).toFixed(2)} ${Y(arr[0]).toFixed(2)}`;
  for(let i=1;i<N;i++) d += ` L ${X(i).toFixed(2)} ${Y(arr[i]).toFixed(2)}`;

  const cls = change==null ? '' : (change>=0 ? 'up' : 'down');

  const dataTemps = arr.join(' ');
  const dataTimes = (times || []).join(' ');

  return `
    <svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none"
         data-temps="${dataTemps}" data-times="${dataTimes}"
         data-min="${min}" data-max="${max}">
      <path class="axis" d="M ${pad} ${Y(min)} H ${w-pad}"></path>
      <path class="line ${cls}" d="${d}"></path>
      <circle class="marker" r="2.5" cx="${X(N-1)}" cy="${Y(arr[N-1])}"></circle>
      <rect class="hit" x="0" y="0" width="${w}" height="${h}"></rect>
    </svg>
  `;
}

function render(){
  const tbody = document.getElementById('body');
  const table = document.getElementById('tbl');
  const status = document.getElementById('status');
  if(!ticks.length){ table.hidden = true; return; }
  let arr = [...ticks].sort((a,b)=>{
    if (typeof a[sortBy] === 'string') return a[sortBy].localeCompare(b[sortBy]);
    return (b[sortBy] ?? -Infinity) - (a[sortBy] ?? -Infinity);
  });

  tbody.innerHTML = arr.map(x=>{
    const ch = x.change;
    const chTxt = (ch==null) ? '—' : `${ch>=0?'+':''}${ch.toFixed(2)}°C`;
    const chClass = ch==null ? '' : (ch>=0?'up':'down');
    return `
      <tr>
        <td><span class="flag">${x.flag}</span>${x.name}</td>
        <td class="right">${x.price.toFixed(1)}°C</td>
        <td class="spark">${sparkSVG(x.temps24, x.times24, x.change)}</td>
        <td class="right ${chClass}">${chTxt}</td>
        <td class="right">${x.cap.toFixed(2)}</td>
      </tr>
    `;
  }).join('');

  table.hidden = false;
  status.textContent = `Dernière maj : ${new Date().toLocaleTimeString()} · ${ticks.length} coins`;

  // active tooltips pour tous les sparklines rendus
  attachTooltips();
}

/** --- Tooltip utils --- */
const TIP = document.getElementById('tip');

function yFrom(v, min, max, h=36, pad=3){
  const span = (max-min) || 1;
  return h - (pad + ((v-min)*(h-2*pad)/span));
}

function attachTooltips(){
  document.querySelectorAll('.spark svg').forEach(svg=>{
    const temps = (svg.dataset.temps || '').split(' ').map(parseFloat).filter(n=>!Number.isNaN(n));
    const times = (svg.dataset.times || '').split(' ');
    if(temps.length < 2) return;

    const w=140, h=36, pad=3, N=temps.length;
    const xToIndex = (x) => {
      const t = Math.round((x - pad) * (N-1) / (w - 2*pad));
      return Math.max(0, Math.min(N-1, t));
    };
    const min = parseFloat(svg.dataset.min), max = parseFloat(svg.dataset.max);
    const marker = svg.querySelector('.marker');

    svg.addEventListener('mousemove', (e)=>{
      const r = svg.getBoundingClientRect();
      const x = e.clientX - r.left;
      const i = xToIndex(x);
      const v = temps[i];
      const cx = pad + (i*(w-2*pad))/(N-1);
      const cy = yFrom(v, min, max, h, pad);

      // marqueur
      marker.setAttribute('cx', cx);
      marker.setAttribute('cy', cy);
      marker.style.display = 'block';

      // tooltip
      const dt = times[i] ? new Date(times[i]) : null;
      const when = dt ? dt.toLocaleString() : '';
      TIP.textContent = `${v.toFixed(1)}°C · ${when}`;
      TIP.style.display = 'block';

      // position (évite de dépasser à droite)
      const offsetX = 14, offsetY = 12;
      let left = e.clientX + offsetX;
      let top  = e.clientY + offsetY;
      const tipRect = TIP.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      if(left + tipRect.width > vw - 6) left = e.clientX - tipRect.width - offsetX;
      if(top + tipRect.height > vh - 6) top = e.clientY - tipRect.height - offsetY;
      TIP.style.left = left + 'px';
      TIP.style.top  = top  + 'px';
    });

    svg.addEventListener('mouseleave', ()=>{
      marker.style.display = 'none';
      TIP.style.display = 'none';
    });
  });
}

/** --- Fetch Open-Meteo pour chaque ville --- */
async function fetchCity(c){
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.searchParams.set('latitude', c.lat);
  url.searchParams.set('longitude', c.lon);
  url.searchParams.set('current_weather', 'true');
  url.searchParams.set('hourly', 'temperature_2m');
  url.searchParams.set('past_days', '1');           // hier
  url.searchParams.set('forecast_days', '1');       // aujourd'hui
  url.searchParams.set('timezone', 'auto');         // fuseau local

  const res = await fetch(url.toString());
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  const js = await res.json();

  const nowTemp = js.current_weather?.temperature;      // °C
  const wind = js.current_weather?.windspeed ?? 0;      // km/h
  const nowTime = js.current_weather?.time;             // ISO

  const times = js.hourly?.time || [];
  const temps = js.hourly?.temperature_2m || [];

  let idxNow = times.indexOf(nowTime);
  if (idxNow === -1) idxNow = times.length - 1;

  // Série des 24 dernières heures (incluant maintenant si possible)
  let temps24 = [], times24 = [];
  if (idxNow >= 0) {
    const start = Math.max(0, idxNow - 23);
    temps24 = temps.slice(start, idxNow + 1);
    times24 = times.slice(start, idxNow + 1);
  }

  // Variation 24h = maintenant - (il y a 24h)
  let change = null;
  if (idxNow >= 24 && Number.isFinite(nowTemp) && Number.isFinite(temps[idxNow-24])) {
    change = nowTemp - temps[idxNow-24];
  }

  const cap = (nowTemp ?? 0) * (1 + (wind/100));

  return {
    name: `${c.country} (${c.city})`,
    flag: c.flag,
    price: nowTemp ?? Number.NaN,
    change,
    cap,
    temps24,
    times24
  };
}

async function loadAll(){
  const loading = document.getElementById('loading');
  const status = document.getElementById('status');
  loading.textContent = 'Fetching les ticks météo…';
  status.textContent = 'Chargement…';

  const results = await Promise.allSettled(COINS.map(fetchCity));
  ticks = results
    .filter(r=>r.status==='fulfilled')
    .map(r=>r.value)
    .filter(x=>Number.isFinite(x.price));

  const fails = results.filter(r=>r.status==='rejected').length;
  loading.textContent = fails>0 ? `OK (${ticks.length}) · ${fails} échec(s) API` : '';
  render();
}

// Première charge + refresh périodique
loadAll();
setInterval(loadAll, 5*60*1000); // 5 minutes
</script>
</body>
</html>
